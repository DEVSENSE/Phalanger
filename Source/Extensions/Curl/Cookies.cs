using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using PHP.Core;
using System.IO;

namespace PHP.Library.Curl
{
    static class Cookies
    {

        public enum NetscapeCookieToken : int
        {
            Domain = 0,
            TailMatch = 1,
            Path = 2,
            Secure = 3,
            Expires = 4,
            Name = 5,
            Value = 6
        }

        /// <summary>
        /// Formats a string for Netscape output file, w/o a newline at the end.
        /// </summary>
        /// <param name="cookie">Cookie to format</param>
        /// <returns></returns>
        public static string ToNetscapeFormat(this Cookie cookie)
        {
            return String.Format(
              "{0}" +     /* httponly preamble */
              "{1}{2}\t" + /* domain */
              "{3}\t" +   /* tailmatch */
              "{4}\t" +   /* path */
              "{5}\t" +   /* secure */
              "{6}\t" +   /* expires */
              "{7}\t" +   /* name */
              "{8}",    /* value */
              cookie.HttpOnly ? "#HttpOnly_" : "",
                /* Make sure all domains are prefixed with a dot if they allow
                   tailmatching. This is Mozilla-style. */
              String.Empty,//TODO: (cookie.Domain->tailmatch && co->domain && co->domain[0] != '.')? ".":"",
              cookie.Domain ?? "unknown",
              cookie.Domain != null && cookie.Domain[0] == '.' ? "TRUE" : "FALSE",
              cookie.Path != null ? cookie.Path : "/",
              cookie.Secure ? "TRUE" : "FALSE",
              (cookie.Expires - new DateTime(1970, 1, 1)).TotalSeconds,
              cookie.Name,
              cookie.Value);
        }



        /// <summary>
        /// Writes all internally known cookies to the specified file. 
        /// </summary>
        /// <param name="cookies">Cookies to dump</param>
        /// <param name="dumpFile">Path to file where to dump cookie. Specify '-' to write to stdout
        /// </param>
        public static void CookieOutput(CookieCollection cookies, string dumpFile)
        {
            System.IO.TextWriter output = null;
            bool use_stdoutput = false;

            if (cookies == null || cookies.Count == 0)
            {
                //If there are no known cookies, we don't write or even create any
                //destination file

                return;
            }


            if (dumpFile == "-")
            {
                output = ScriptContext.CurrentContext.Output;
                use_stdoutput = true;
            }
            else
            {
                output = new System.IO.StreamWriter(dumpFile);
                //output.NewLine = "\r";
            }

            try
            {
                output.WriteLine("# Netscape HTTP Cookie File");
                output.WriteLine("# http://curl.haxx.se/rfc/cookie_spec.html");
                output.WriteLine("# This file was generated by managed curl! Edit at your own risk.");
                output.WriteLine();

                foreach (Cookie cookie in cookies)
                {
                    output.WriteLine(cookie.ToNetscapeFormat());
                }

            }
            finally
            {
                if (!use_stdoutput)
                    output.Close();
            }
        }


        //ORIGINAL void Curl_flush_cookies(struct SessionHandle *data, int cleanup)
        public static void FlushCookies(UserDefined data/*, int cleanup*/)
        {
            string cookieJar = data.Str[(int)DupString.COOKIEJAR] as string;

            if (!String.IsNullOrEmpty(cookieJar))
            {
                var cookies = data.Cookies;

                string fullPath = Path.Combine(ScriptContext.CurrentContext.WorkingDirectory, cookieJar);


                //TODO: check the file lock Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
                try
                {
                    CookieOutput(cookies, cookieJar);
                }
                catch (Exception ex)
                {
                    // do nothing
                    PhpException.Throw(PhpError.Warning, String.Format("WARNING: failed to save cookies in {0}; {1}\n", cookieJar, ex.Message));
                }

                //  }
                //  else {
                //    if(cleanup && data->change.cookielist)
                //      /* since nothing is written, we can just free the list of cookie file
                //         names */
                //      curl_slist_free_all(data->change.cookielist); /* clean up list */
                //    Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
                //  }

                //  if(cleanup && (!data->share || (data->cookies != data->share->cookies))) {
                //    Curl_cookie_cleanup(data->cookies);
                //  }
                //  Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
            }

        }


        public static void LoadCookiesFromFiles(CookieCollection/*!*/ cookies, List<string> cookiesFileList)
        {
            Debug.Assert(cookies != null);

            Cookie cookie;
            StringBuilder content = new StringBuilder();

            foreach (string file in cookiesFileList)
            {
                //Current Working Directory
                try
                {

                    if (File.Exists(file))
                        content.Append(File.ReadAllText(file));
                }
                catch (Exception)
                {
                    //Ignore a problem as native curl does
                }
            }
            //TODO: determine if it's netscape cookie format dump or normal cookie dump and for now at least throw exception in this case
            string line; 
            using (TextReader reader = new StringReader(content.ToString()))
            {
                while ((line = reader.ReadLine()) != null)
                {
                    cookie = ParseCookieNetscapeFormatLine(line);

                    if (cookie != null)
                        cookies.Add(cookie);
                }

            }
            //cookies.SetCookies(uri, content.ToString());

        }

        public static Cookie ParseCookieNetscapeFormatLine(string cookieLine)
        {
            Cookie resCookie = new Cookie();

            if (cookieLine.Length == 0)
                return null;

            if (cookieLine[0] == '#')
            {
                //  IE introduced HTTP-only cookies to prevent XSS attacks. Cookies
                //  marked with httpOnly after the domain name are not accessible
                //  from javascripts, but since curl does not operate at javascript
                //  level, we include them anyway. In Firefox's cookie files, these
                //  lines are preceeded with #HttpOnly_ and then everything is
                //  as usual, so we skip 10 characters of the line..

                if (cookieLine.StartsWith("#HttpOnly_"))
                {
                    cookieLine = cookieLine.Substring(10);
                    resCookie.HttpOnly = true;//native curl just skip this and doesn't remember it
                }
                else
                {
                    //It's a comment
                    return null;
                }
            }

            //Trim end of line characters
            cookieLine.TrimEnd('\n', '\r');

            String[] parts = cookieLine.Split('\t');

            // quick check to eliminate normal HTTP-headers from this ??

            int field = 0;
            foreach (string part in parts)
            {
                switch ((NetscapeCookieToken)field)
                {

                    case NetscapeCookieToken.Domain:
                        //
                        //if (part[0] == '.')
                        //    resCookie.Domain = part.Substring(1);
                        //else
                        //    resCookie.Domain = part;

                        resCookie.Domain = part;
                        break;

                    case NetscapeCookieToken.TailMatch:

                        // This field got its explanation on the 23rd of May 2001 by
                        //Andrés García:

                        //flag: A TRUE/FALSE value indicating if all machines within a given
                        //domain can access the variable. This value is set automatically by
                        //the browser, depending on the value you set for the domain.

                        //As far as I can see, it is set to true when the cookie says
                        //.domain.com and to false when the domain is complete www.domain.com

                        //skiping this for now
                        break;

                    case NetscapeCookieToken.Path:

                        //Path part

                        /* It turns out, that sometimes the file format allows the path
                        field to remain not filled in, we try to detect this and work
                        around it! Andrés García made us aware of this... */
                        if (!part.Equals("TRUE", StringComparison.OrdinalIgnoreCase) &&
                            !part.Equals("FALSE", StringComparison.OrdinalIgnoreCase))
                        {
                            /* only if the path doesn't look like a boolean option! */
                            resCookie.Path = part;
                        }
                        else
                        {
                            /* this doesn't look like a path, make one up! */
                            resCookie.Path = "/";

                            /* add a field and fall down to secure */
                            /* FALLTHROUGH */
                            ++field;
                            goto case NetscapeCookieToken.Secure;
                        }

                        break;

                    case NetscapeCookieToken.Secure:

                        if (part.Equals("TRUE", StringComparison.OrdinalIgnoreCase))
                            resCookie.Secure = true;

                        break;

                    case NetscapeCookieToken.Expires:

                        long expires;

                        if (long.TryParse(part, out expires))
                        {
                            resCookie.Expires = new DateTime(1970, 1, 1).AddSeconds(expires);
                        }
                        else
                        {
                            //Not valid cookie
                            return null;
                        }
                        break;

                    case NetscapeCookieToken.Name:
                        resCookie.Name = part;
                        break;

                    case NetscapeCookieToken.Value:
                        resCookie.Value = part;
                        break;
                }

                ++field;
            }

            return resCookie;
        }
        
    }
}
