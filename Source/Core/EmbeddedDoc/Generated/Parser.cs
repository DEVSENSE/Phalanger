// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005
// (see accompanying GPPGcopyright.rtf)


using System;
using System.Text;
using System.Collections.Generic;

/*

 Copyright (c) 2012 DEVSENSE

 Parser was generated using The Gardens Point Parser Generator (GPPG).

 The use and distribution terms for this software are contained in the file named License.txt, 
 which can be found in the root of the Phalanger distribution. By using this software 
 in any fashion, you are agreeing to be bound by the terms of this license.
 
 You must not remove this notice from this software.
 
*/

using PHP.Core;
using PHP.Core.EmbeddedDoc;
using PHP.Core.Parsers.GPPG;


namespace PHP.Core.EmbeddedDoc
{
public enum Tokens {ERROR=1,EOF=2,T_WHITESPACE=3,T_NEWLINE=4,T_LINE_BEGIN=5,T_BEGIN=6,T_END=7,T_DOLLAR=8,T_BAR=9,T_LBRA=10,T_RBRA=11,T_RCURLY=12,T_IDENTIFIER=13,T_SYMBOL=14,T_INTEGER=15,T_COMPOUND=16,T_ARRAY=17,T_PRIVATE=18,T_PROTECTED=19,T_PUBLIC=20,T_ELEMENT_PARAM=21,T_ELEMENT_RETURN=22,T_ELEMENT_VAR=23,T_ELEMENT_ACCESS=24,T_INLINE_LINK=25};

public partial struct SemanticValueType
{
	public string String;
	public object Object;
}
public partial struct Position
{
  public int FirstLine;
  public int FirstColumn;
  public int FirstOffset;
  public int LastLine;
  public int LastColumn;
  public int LastOffset;

  public Position(int firstLine, int firstColumn, int firstOffset, int lastLine, int lastColumn, int lastOffset)
  {
    this.FirstLine = firstLine;
    this.FirstColumn = firstColumn;
    this.FirstOffset = firstOffset;
    this.LastLine = lastLine;
    this.LastColumn = lastColumn;
    this.LastOffset = lastOffset;
  }
}
public  partial class Parser: ShiftReduceParser<SemanticValueType,Position>
{

  protected override string[] NonTerminals { get { return nonTerminals; } }
  private static string[] nonTerminals;

  protected override State[] States { get { return states; } }
  private static State[] states;

  protected override Rule[] Rules { get { return rules; } }
  private static Rule[] rules;

  protected sealed override Position CombinePositions(Position first, Position last)
  {
    return new Position(first.FirstLine, first.FirstColumn, first.FirstOffset, last.LastLine, last.LastColumn, last.LastOffset);
  }

  #region Construction

  static Parser()
  {

    states = new State[]
    {
      new State(0, -16, new int[] {-1,1,-6,3,-15,15}),
      new State(1, new int[] {2,2}),
      new State(2, -1),
      new State(3, -4, new int[] {-2,4}),
      new State(4, new int[] {21,8,22,45,23,50,24,55,2,-2}, new int[] {-3,5}),
      new State(5, -11, new int[] {-14,6}),
      new State(6, new int[] {3,7,21,-3,22,-3,23,-3,24,-3,2,-3}),
      new State(7, -10),
      new State(8, new int[] {3,9}),
      new State(9, new int[] {13,36,17,37,8,28}, new int[] {-9,10,-4,30,-10,33,-11,44,-12,27}),
      new State(10, new int[] {3,11}),
      new State(11, new int[] {8,28}, new int[] {-4,12,-12,27}),
      new State(12, new int[] {3,13}),
      new State(13, -16, new int[] {-6,14,-15,15}),
      new State(14, -5),
      new State(15, -20, new int[] {-7,16}),
      new State(16, new int[] {16,19,25,20,21,-17,22,-17,23,-17,24,-17,2,-17,3,-17}, new int[] {-16,17,-8,18}),
      new State(17, -18),
      new State(18, -19),
      new State(19, -21),
      new State(20, -22, new int[] {-17,21}),
      new State(21, new int[] {3,22}),
      new State(22, new int[] {13,23}),
      new State(23, -23, new int[] {-18,24}),
      new State(24, new int[] {16,25}),
      new State(25, new int[] {12,26}),
      new State(26, -24),
      new State(27, -15),
      new State(28, new int[] {13,29}),
      new State(29, -34),
      new State(30, new int[] {3,31}),
      new State(31, -16, new int[] {-6,32,-15,15}),
      new State(32, -6),
      new State(33, new int[] {9,34,3,-25}),
      new State(34, new int[] {13,36,17,37}, new int[] {-11,35}),
      new State(35, -26),
      new State(36, -28),
      new State(37, new int[] {10,38,9,-29,3,-29,11,-29}),
      new State(38, new int[] {11,39,13,36,17,37}, new int[] {-11,41}),
      new State(39, new int[] {13,36,17,37,9,-30,3,-30,11,-30}, new int[] {-11,40}),
      new State(40, -32),
      new State(41, new int[] {11,42}),
      new State(42, new int[] {13,36,17,37,9,-31,3,-31,11,-31}, new int[] {-11,43}),
      new State(43, -33),
      new State(44, -27),
      new State(45, new int[] {3,46}),
      new State(46, new int[] {13,36,17,37}, new int[] {-9,47,-10,33,-11,44}),
      new State(47, new int[] {3,48}),
      new State(48, -16, new int[] {-6,49,-15,15}),
      new State(49, -7),
      new State(50, new int[] {3,51}),
      new State(51, new int[] {13,36,17,37}, new int[] {-9,52,-10,33,-11,44}),
      new State(52, new int[] {3,53}),
      new State(53, -16, new int[] {-6,54,-15,15}),
      new State(54, -8),
      new State(55, new int[] {3,56}),
      new State(56, new int[] {20,59,18,60,19,61}, new int[] {-5,57}),
      new State(57, -16, new int[] {-6,58,-15,15}),
      new State(58, -9),
      new State(59, -12),
      new State(60, -13),
      new State(61, -14),
    };

    rules = new Rule[35];
    rules[1]=new Rule(-13, new int[]{-1,2});
    rules[2]=new Rule(-1, new int[]{-6,-2});
    rules[3]=new Rule(-2, new int[]{-2,-3,-14});
    rules[4]=new Rule(-2, new int[]{});
    rules[5]=new Rule(-3, new int[]{21,3,-9,3,-4,3,-6});
    rules[6]=new Rule(-3, new int[]{21,3,-4,3,-6});
    rules[7]=new Rule(-3, new int[]{22,3,-9,3,-6});
    rules[8]=new Rule(-3, new int[]{23,3,-9,3,-6});
    rules[9]=new Rule(-3, new int[]{24,3,-5,-6});
    rules[10]=new Rule(-14, new int[]{-14,3});
    rules[11]=new Rule(-14, new int[]{});
    rules[12]=new Rule(-5, new int[]{20});
    rules[13]=new Rule(-5, new int[]{18});
    rules[14]=new Rule(-5, new int[]{19});
    rules[15]=new Rule(-4, new int[]{-12});
    rules[16]=new Rule(-15, new int[]{});
    rules[17]=new Rule(-16, new int[]{});
    rules[18]=new Rule(-6, new int[]{-15,-7,-16});
    rules[19]=new Rule(-7, new int[]{-7,-8});
    rules[20]=new Rule(-7, new int[]{});
    rules[21]=new Rule(-8, new int[]{16});
    rules[22]=new Rule(-17, new int[]{});
    rules[23]=new Rule(-18, new int[]{});
    rules[24]=new Rule(-8, new int[]{25,-17,3,13,-18,16,12});
    rules[25]=new Rule(-9, new int[]{-10});
    rules[26]=new Rule(-10, new int[]{-10,9,-11});
    rules[27]=new Rule(-10, new int[]{-11});
    rules[28]=new Rule(-11, new int[]{13});
    rules[29]=new Rule(-11, new int[]{17});
    rules[30]=new Rule(-11, new int[]{17,10,11});
    rules[31]=new Rule(-11, new int[]{17,10,-11,11});
    rules[32]=new Rule(-11, new int[]{17,10,11,-11});
    rules[33]=new Rule(-11, new int[]{17,10,-11,11,-11});
    rules[34]=new Rule(-12, new int[]{8,13});

    nonTerminals = new string[] {"", "start", "element_block", "element", 
      "identifier_attribute", "access_modifier", "compound_attribute", "expression_list", 
      "expression", "type_attribute", "type_list", "type", "variable", "$accept", 
      "whitespace_option", "@1", "@2", "@3", "@4", };
  }

  #endregion

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // start -> compound_attribute element_block 
{ 
			(value_stack.array[value_stack.top-1].yyval.Object as List<Tuple<DocElementType,DocElement>>).Add(new Tuple<DocElementType,DocElement>(DocElementType.Summary, new DocSummaryElement(value_stack.array[value_stack.top-2].yyval.Object as DocCompoundAttribute))); 
			yyval.Object = value_stack.array[value_stack.top-1].yyval.Object; 
			elements = (value_stack.array[value_stack.top-1].yyval.Object as List<Tuple<DocElementType,DocElement>>).ToArray(); 
		}
        return;
      case 3: // element_block -> element_block element whitespace_option 
{ (value_stack.array[value_stack.top-3].yyval.Object as List<Tuple<DocElementType,DocElement>>).Add(value_stack.array[value_stack.top-2].yyval.Object as Tuple<DocElementType,DocElement>); yyval.Object = value_stack.array[value_stack.top-3].yyval.Object; }
        return;
      case 4: // element_block -> 
{ yyval.Object = new List<Tuple<DocElementType,DocElement>>(); }
        return;
      case 5: // element -> T_ELEMENT_PARAM T_WHITESPACE type_attribute T_WHITESPACE identifier_attribute T_WHITESPACE compound_attribute 
{ yyval.Object = new Tuple<DocElementType,DocElement>(DocElementType.Param, new DocParamElement(value_stack.array[value_stack.top-5].yyval.Object as DocTypeAttribute, value_stack.array[value_stack.top-3].yyval.Object as DocIdentifierAttribute, value_stack.array[value_stack.top-1].yyval.Object as DocCompoundAttribute)); }
        return;
      case 6: // element -> T_ELEMENT_PARAM T_WHITESPACE identifier_attribute T_WHITESPACE compound_attribute 
{ yyval.Object = new Tuple<DocElementType,DocElement>(DocElementType.Param, new DocParamElement(null, value_stack.array[value_stack.top-3].yyval.Object as DocIdentifierAttribute, value_stack.array[value_stack.top-1].yyval.Object as DocCompoundAttribute)); }
        return;
      case 7: // element -> T_ELEMENT_RETURN T_WHITESPACE type_attribute T_WHITESPACE compound_attribute 
{ yyval.Object = new Tuple<DocElementType,DocElement>(DocElementType.Return, new DocReturnElement(value_stack.array[value_stack.top-3].yyval.Object as DocTypeAttribute, value_stack.array[value_stack.top-1].yyval.Object as DocCompoundAttribute)); }
        return;
      case 8: // element -> T_ELEMENT_VAR T_WHITESPACE type_attribute T_WHITESPACE compound_attribute 
{ yyval.Object = new Tuple<DocElementType,DocElement>(DocElementType.Var, new DocVarElement(value_stack.array[value_stack.top-3].yyval.Object as DocTypeAttribute, value_stack.array[value_stack.top-1].yyval.Object as DocCompoundAttribute)); }
        return;
      case 9: // element -> T_ELEMENT_ACCESS T_WHITESPACE access_modifier compound_attribute 
{ yyval.Object = new Tuple<DocElementType,DocElement>(DocElementType.Access, new DocAccessElement(new DocAccessModifierAttribute((DocAccessModifier)(value_stack.array[value_stack.top-2].yyval.Object)))); }
        return;
      case 12: // access_modifier -> T_PUBLIC 
{ yyval.Object = DocAccessModifier.Public; }
        return;
      case 13: // access_modifier -> T_PRIVATE 
{ yyval.Object = DocAccessModifier.Private; }
        return;
      case 14: // access_modifier -> T_PROTECTED 
{ yyval.Object = DocAccessModifier.Protected; }
        return;
      case 15: // identifier_attribute -> variable 
{ yyval.Object = new DocIdentifierAttribute(value_stack.array[value_stack.top-1].yyval.String); }
        return;
      case 16: // @1 -> 
{ CompoundTokens = true; }
        return;
      case 17: // @2 -> 
{ CompoundTokens = false; }
        return;
      case 18: // compound_attribute -> @1 expression_list @2 
{ yyval.Object = new DocCompoundAttribute(value_stack.array[value_stack.top-2].yyval.Object as List<DocExpression>); }
        return;
      case 19: // expression_list -> expression_list expression 
{ (value_stack.array[value_stack.top-2].yyval.Object as List<DocExpression>).Add(value_stack.array[value_stack.top-1].yyval.Object as DocExpression); yyval.Object = value_stack.array[value_stack.top-2].yyval.Object; }
        return;
      case 20: // expression_list -> 
{ yyval.Object = new List<DocExpression>(); }
        return;
      case 21: // expression -> T_COMPOUND 
{ yyval.Object = new DocTextExpr(value_stack.array[value_stack.top-1].yyval.String.ToString()); }
        return;
      case 22: // @3 -> 
{ CompoundTokens = false; }
        return;
      case 23: // @4 -> 
{ CompoundTokens = true; }
        return;
      case 24: // expression -> T_INLINE_LINK @3 T_WHITESPACE T_IDENTIFIER @4 T_COMPOUND T_RCURLY 
{ yyval.Object = new DocLinkExpr(value_stack.array[value_stack.top-5].yyval.String.ToString(), value_stack.array[value_stack.top-4].yyval.String.ToString()); }
        return;
      case 25: // type_attribute -> type_list 
{ yyval.Object = new DocTypeAttribute(value_stack.array[value_stack.top-1].yyval.Object as List<DocRawType>); }
        return;
      case 26: // type_list -> type_list T_BAR type 
{ (value_stack.array[value_stack.top-3].yyval.Object as List<DocRawType>).Add(value_stack.array[value_stack.top-1].yyval.Object as DocRawType); yyval.Object = value_stack.array[value_stack.top-3].yyval.Object; }
        return;
      case 27: // type_list -> type 
{ yyval.Object = new List<DocRawType>(); (yyval.Object as List<DocRawType>).Add(value_stack.array[value_stack.top-1].yyval.Object as DocRawType); }
        return;
      case 28: // type -> T_IDENTIFIER 
{ yyval.Object = new DocRawTypeIdentifier(value_stack.array[value_stack.top-1].yyval.String.ToString()); }
        return;
      case 29: // type -> T_ARRAY 
{ yyval.Object = new DocRawTypeArray(null, null); }
        return;
      case 30: // type -> T_ARRAY T_LBRA T_RBRA 
{ yyval.Object = new DocRawTypeArray(null, null); }
        return;
      case 31: // type -> T_ARRAY T_LBRA type T_RBRA 
{ yyval.Object = new DocRawTypeArray(value_stack.array[value_stack.top-2].yyval.Object as DocRawType, null); }
        return;
      case 32: // type -> T_ARRAY T_LBRA T_RBRA type 
{ yyval.Object = new DocRawTypeArray(null, value_stack.array[value_stack.top-1].yyval.Object as DocRawType); }
        return;
      case 33: // type -> T_ARRAY T_LBRA type T_RBRA type 
{ yyval.Object = new DocRawTypeArray(value_stack.array[value_stack.top-3].yyval.Object as DocRawType, value_stack.array[value_stack.top-1].yyval.Object as DocRawType); }
        return;
      case 34: // variable -> T_DOLLAR T_IDENTIFIER 
{ yyval.String = value_stack.array[value_stack.top-1].yyval.String; }
        return;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (((Tokens)terminal).ToString() != terminal.ToString())
      return ((Tokens)terminal).ToString();
    else
      return CharToString((char)terminal);
  }


}
}
